# 执行上下文概念
javascript代码运行时所在环境的抽象概念

> 通俗说就是js在程序开始执行前或者函数调用的时候会先有一个准备阶段也就是**预编译**阶段,这个阶段会提供给接下来要执行的代码一个环境.这个环境会将当前代码片段定义的所有函数和变量与它们对应的值关联起来,以及不在当前代码片段定义的变量(自由变量)是否可以访问以及如何访问.(自己的理解)

不同的代码片段会有不同类型的执行上下文,可以将这些代码片段分为:
* 全局代码
* 函数代码
* 模块代码
* eval代码 (这是个什么玩意儿)

## 执行栈
就是规定了这些执行上下文应该按照什么样的顺序被执行.

给一个例子

    let a = 'Hello World!';

    function first() {
      console.log('Inside first function');
      second();
      console.log('Again inside first function');
    }

    function second() {
      console.log('Inside second function');
    }

    first();
    console.log('Inside Global Execution Context');
  
它的执行顺序:

  * 程序执行前压入一个全局上下文
  * 调用first() 压入一个函数上下文,开始执行first上下文
  * first函数内调用了second函数又压入了一个函数上下文,开始执行second上下文

  * second函数执行完毕释放second上下文
  * 继续执行first上下文
  * first上下文执行完毕,释放first上下文
  * 继续执行全局上下文
  * 全局上下文执行完毕,释放全局上下文
  * 程序结束

*随缘笔记,懒得画图...就是一个递归的概念,遵循后进先出原则*


## 执行上下文包括

* this绑定

函数调用根据对应上下文绑定的

* 词法环境(作用域?)
  * 声明式环境记录器
    
    * 记录let,const声明
    
    * outer(作用域链?)
      
      > 外部词法环境的引用,函数定义时就被保存

  * 变量环境记录器
    > 记录var,function


*作用域跟词法环境不一样的地方是在作用域**只是规定了一个可访问范围,并且在函数定义的时候生成**词法环境则是具体实现.在闭包的情况下一个作用域可能会出现两个上下文.*

## this
上下文的创建阶段就会绑定当前this,全局作用域下是window对象,函数或者对象内部为他们自身.

函数调用的时候会隐式的传入当前上下文绑定的this,五种不同方式的函数调用的this指向:

* 函数的普通调用 --->window
* 函数作为对象方法调用 --->对象自身
* 函数作为构造函数调用 ---> 构造函数
* 函数通过call、apply、bind间接调用 --->指向传进去的对象
* 箭头函数的调用 --->不绑定this指向作用域链最近的上下文绑定的this值




## 闭包
通常指的是函数内部的上下文被保存到了函数外部,然后导致了什么内存泄漏啊,什么的巴拉巴拉.

有什么用呢
* 框架使用闭包来只对外暴露接口.
* 计数器(调用一次加一次?)
* 一次性计算(使用闭包保存)




参考文章:
  [理解 JavaScript 中的执行上下文和执行栈](https://juejin.im/post/5ba32171f265da0ab719a6d7#heading-3)